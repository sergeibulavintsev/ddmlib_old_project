/*
 * ChunkHandler.h
 *
 *  Created on: 02.02.2012
 *      Author: sergey bulavintsev
 */

#ifndef CHUNKHANDLER_HPP_
#define CHUNKHANDLER_HPP_
#include "ddmlib.hpp"

class ByteBuffer;

namespace ddmlib {

class Client;
class DebugPortManager;
class AndroidDebugBridge;
class JdwpPacket;

class DDMLIB_LOCAL ChunkHandler {
public:
	ChunkHandler();
	virtual ~ChunkHandler();

	static const int CHUNK_HEADER_LEN; // 4-byte type, 4-byte len
	static bool CHUNK_ORDER; //ByteOrder.BIG_ENDIAN;

	static int CHUNK_FAIL;

	/**
	 * Client is ready.  The monitor thread calls this method on all
	 * handlers when the client is determined to be DDM-aware (usually
	 * after receiving a HELO response.)
	 *
	 * The handler can use this opportunity to initialize client-side
	 * activity.  Because there's a fair chance we'll want to send a
	 * message to the client, this method can throw an IOException.
	 */
	virtual void clientReady(std::tr1::shared_ptr<Client> client) = 0;

	/**
	 * Client has gone away.  Can be used to clean up any resources
	 * associated with this client connection.
	 */
	virtual void clientDisconnected(std::tr1::shared_ptr<Client> client) = 0;

	/**
	 * Handle an incoming chunk.  The data, of chunk type "type", begins
	 * at the start of "data" and continues to data.limit().
	 *
	 * If "isReply" is set, then "msgId" will be the ID of the request
	 * we sent to the client.  Otherwise, it's the ID generated by the
	 * client for this event.  Note that it's possible to receive chunks
	 * in reply packets for which we are not registered.
	 *
	 * The handler may not modify the contents of "data".
	 */
	virtual void handleChunk(std::tr1::shared_ptr<Client> client, int type, std::tr1::shared_ptr<ByteBuffer> data, bool isReply,
			int msgId) = 0;

	/**
	 * Utility function to copy a String out of a ByteBuffer.
	 *
	 * This is here because multiple chunk handlers can make use of it,
	 * and there's nowhere better to put it.
	 */
	static std::wstring getString(std::tr1::shared_ptr<ByteBuffer> buf, int len);

	/**
	 * Utility function to copy a String into a ByteBuffer.
	 */
	static void putString(std::tr1::shared_ptr<ByteBuffer> buf, const std::wstring& str);

	/**
	 * Convert a 4-character string to a 32-bit type.
	 */
	static int type(const std::string &typeName);

	/**
	 * Convert an integer type to a 4-character string.
	 */
	static std::string name(int type);
	/**
	 * Allocate a ByteBuffer with enough space to hold the JDWP packet
	 * header and one chunk header in addition to the demands of the
	 * chunk being created.
	 *
	 * "maxChunkLen" indicates the size of the chunk contents only.
	 */
	static std::tr1::shared_ptr<ByteBuffer> allocBuffer(int maxChunkLen);

	/**
	 * Return the slice of the JDWP packet buffer that holds just the
	 * chunk data.
	 */
	static std::tr1::shared_ptr<ByteBuffer> getChunkDataBuf(std::tr1::shared_ptr<ByteBuffer> jdwpBuf);

	/**
	 * Write the chunk header at the start of the chunk.
	 *
	 * Pass in the byte buffer returned by JdwpPacket.getPayload().
	 */
	static void finishChunkPacket(std::tr1::shared_ptr<JdwpPacket> packet, int type, int chunkLen);
	static void registerChunkHandler(int type, std::tr1::shared_ptr<ChunkHandler> handler);
	static void broadcast(int event, std::tr1::shared_ptr<Client> client);
	static void callHandler(std::tr1::shared_ptr<Client> client, std::tr1::shared_ptr<JdwpPacket> packet,
			std::tr1::shared_ptr<ChunkHandler> handler);

protected:
	/**
	 * Handle chunks not recognized by handlers.  The handleChunk() method
	 * in sub-classes should call this if the chunk type isn't recognized.
	 */
	void handleUnknownChunk(std::tr1::shared_ptr<Client> client, int type, std::tr1::shared_ptr<ByteBuffer> data, bool isReply,
			int msgId);
	/**
	 * Check that the client is opened with the proper debugger port for the
	 * specified application name, and if not, reopen it.
	 * @param client
	 * @param uiThread
	 * @param appName
	 * @return
	 */
	static std::tr1::shared_ptr<Client> checkDebuggerPortForAppName(std::tr1::shared_ptr<Client> client, const std::wstring &appName);

private:

	static std::map<int, std::tr1::shared_ptr<ChunkHandler> > mHandlerMap;
	static const int CLIENT_READY;
	static const int CLIENT_DISCONNECTED;
	static Poco::FastMutex sLock;
};

} /* namespace ddmlib */
#endif /* CHUNKHANDLER_HPP_ */
